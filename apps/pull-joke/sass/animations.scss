@import 'math';

//////////////////////////// PARABOLA /////////////////////

$framesPerSecond: 20;
$accelerationConstant: -9.81 * 4;

@function sqrt($r) {
  $x0: 1;
  $x1: $x0;
 
  @for $i from 1 through 10 {
    $x1: $x0 - ($x0 * $x0 - abs($r)) / (2 * $x0);
    $x0: $x1;
  }
 
  @return $x1;
}

@function round2Decimals($number) {
  @return round($number * 100) / 100;
}

@mixin parabola-core($xSpeed, $ySpeed, $rotation, $parabolaTime) {
  $framesNumber: $framesPerSecond * $parabolaTime;
  $frameWeight: 100 / $framesNumber;
  $frameRotation: $rotation / $framesNumber;
  @for $i from 0 through $framesNumber {
    $percent: round2Decimals($i * $frameWeight);
    $time: $percent / 100 * $parabolaTime;
    #{$percent}% {
      $x: round2Decimals($xSpeed * $time);
      $y: ($ySpeed * $time) + ($accelerationConstant * $time * $time);
      $y: -1 * round2Decimals($y); // As the translate function origen of coordinates is oppostie to the conventional one, we multiply the value by -1;
      transform: translate(#{$x}vw, #{$y}vh) rotate(#{round2Decimals($frameRotation * $i)}deg);
    }
  }
  100% {
    $x: round2Decimals($xSpeed * $parabolaTime);
    $y: ($ySpeed * $parabolaTime) + ($accelerationConstant * $parabolaTime * $parabolaTime);
    $y: -1 * round2Decimals($y); // As the translate function origen of coordinates is oppostie to the conventional one, we multiply the value by -1;
    transform: translate(#{$x}vw, #{$y}vh) rotate(#{$rotation}deg);
  }
}

@mixin random-parabola($parabolaId, $finalY) {

  $angle: 60 + random(60);
  $speed: 50 + random(50);
  $rotation: 180 + random(540);

  $xSpeed: $speed * cos($angle);
  $ySpeed: $speed * sin($angle);

  // Accelerated movement equation for the parabola:
  // $finalY = 0 + $ySpeed * $parabolaTime + ($accelerationConstant * $parabolaTime * $parabolaTime);
  // 0 = -$finalY + $ySpeed * $parabolaTime + ($accelerationConstant * $parabolaTime * $parabolaTime);
  // To find the $parabolaTime necessary for the parabola to be at $finalY we need to solve the quadratic equation and take the negative result:
  
  $a: $accelerationConstant;
  $b: $ySpeed;
  $c: -$finalY;

  $parabolaTime: (-$b - sqrt($b * $b - 4 * $a * $c)) / (2 * $a);
  // @debug $a, $b, $c, $parabolaTime;

  @keyframes parabola-keyframe-#{$parabolaId} {
    @include parabola-core($xSpeed, $ySpeed, $rotation, $parabolaTime);
  }

  @-webkit-keyframes parabola-keyframe-#{$parabolaId} {
    @include parabola-core($xSpeed, $ySpeed, $rotation, $parabolaTime);
  }

  .parabola.trajectory-#{$parabolaId} {
    animation: parabola-keyframe-#{$parabolaId} $parabolaTime+s;
    animation-fill-mode: forwards;
    -webkit-animation: parabola-keyframe-#{$parabolaId} $parabolaTime+s;
    -webkit-animation-fill-mode: forwards;
  }
}

///////////////////////////// FREE FALL /////////////////////////////////

@mixin free-falling-core($finalHeight) {
  $framesNumber: 40;

  $maxValue: log($framesNumber + 0.2);
  $frameWeight: 100 / $framesNumber;
  @for $i from 0 through $framesNumber {
    #{$i * $frameWeight}% {
      top: ((log($i + 0.2) / $maxValue) * $finalHeight)+vh;
    }
  }
}

@mixin free-falling($finalHeight) {

  @keyframes free-falling {
    @include free-falling-core($finalHeight);
  }

  @-webkit-keyframes free-falling {
    @include free-falling-core($finalHeight);
  }
}